var version = 1.4;
/*
1.4:  add call to fillChartWithSql
      execEditorContents will carry on chartType
      xhr request + JSON.parse for sqlDict
      call tooltip from here because hiddenTooltip are generated asynchronously
      TODO: progress bar do not fade after loadDb
*/
var execBtn = document.getElementById("execute");
var outputElm = document.getElementById('output');
var errorElm = document.getElementById('error');
var commandsElm = document.getElementById('commands');
var dbFileElm = document.getElementById('dbfile');
var savedbElm = document.getElementById('savedb');

// Start the worker in which sql.js will run
var worker = new Worker("www/js/worker.sql.js");
// alert(worker);
worker.onerror = error;

// Open a database
worker.postMessage({action:'open'});

// Connect to the HTML element we 'print' to
function print(text) {
  outputElm.innerHTML = text.replace(/\n/g, '<br>');
}
function error(e) {
  console.log(e);
  errorElm.style.height = '2em';
  errorElm.textContent = e.message;
  outputElm.textContent = "See error for details.";
}

function noerror() {
  errorElm.style.height = '0';
}

function disableActions(id) {
  $(id).addClass("disabledbutton");
  // console.log("actions disabled");
}
function enableActions(id) {
  $(id).removeClass("disabledbutton");
  // console.log("actions enabled");
}

function formatTimestamp(timestamp) {
  return $.format.date(new Date(parseInt(timestamp+'000')),'yyyy-MM-dd HH:mm:ss');
}

// Run a command in the database
function execute(commands, chartType) {
  tic();
  worker.onmessage = function(event) {
    // console.log(event.data);  // Object { id: undefined, results: Array[1] }
    var results = event.data.results;
    console.log(results);  // Array [ Object ]
    if (results.length == 0) {
      outputElm.textContent = "Request returned 0 rows.";
    } else {
      toc("Executing SQL");

      tic();
      disableActions('#actions');
      // outputElm.innerHTML = ''; // http://jsperf.com/innerhtml-vs-removechild
      outputElm.removeChild(outputElm.firstChild);
      for (var i=0; i<results.length; i++) {
        // for event.data.results = Array [ Object ], results.length = 1
        // console.log('columns='+results[i].columns); // columns=[0:id,1:timestamp,2:ClassNumber,.. x8]
        // console.log('values='+results[i].values);   // values=[0:[1512,1510867045,2792,22,0,22,2,6,7228],.. xNbRows]
        outputElm.appendChild(tableCreate(results[i].columns, results[i].values, 'timestamp', 'formatTimestamp'));
        
        // chart for chartType
        console.log('execute: chartType='+chartType);
        if (chartType && results[i].columns[0] == 'timestamp') { 
          fillChartWithSql(results[i].columns, results[i].values, chartType) 
        } else {
          purgeElement("chart-container");
        };
        // dataTable.jq.js is a table filter and sort plugin:
        var table = $('table').dataTable( {
          "autoWidth": true
        });
      }
    }
    toc("Displaying results");
    enableActions('#actions');
  }
  // try {
    // worker.postMessage({action:'exec',sql:commands});
  // }
  // catch(exception) {
    // worker.postMessage({action:'exec',sql:commands});
  // }
  worker.postMessage({action:'exec', sql:commands});
  outputElm.textContent = "Fetching results...";
}

// Create an HTML table
var tableCreate = function () {
  function openTag(tagName, className) {
    return '<'+tagName+' class="'+className+'">'
  }
  function valconcat(vals, tagName, fieldToFormat, functionToFormat) {
    if (vals.length === 0) return '';
    n = 0
    var open = '<'+tagName+'>', close='</'+tagName+'>';
    // return open + vals.join(close + open) + close;
    theRows='';
    switch (tagName) {
      case 'td':
        // console.log('tr vals='+vals);
        if (timestampCol>-1) {
          // console.log('td timestampCol='+timestampCol);
          // timestamp in tuScraper db is generated by python: timestamp=str(arrow.get(datetime.datetime.now()).timestamp)
          vals[timestampCol] = window[functionToFormat](vals[timestampCol]);
          return open + vals.join(close + open) + close;
        } else {
          return open + vals.join(close + open) + close;
        }
      break;
      case 'th':
        // console.log('th vals='+vals);
        for (i in vals) {
          // console.log('th vals['+i+']='+vals[i]);
          theRows+=openTag(tagName, vals[i].replace(/\W/g, '')) + vals[i] + close;
          if (fieldToFormat) { 
            // console.log('th fieldToFormat='+fieldToFormat);
            if (vals[i] === fieldToFormat) { 
              // console.log('th timestamp=vals['+i+']='+vals[i]);
              timestampCol=i;
            }
          }
        }
      break;
      default:
        return open + vals.join(close + open) + close;
      break;
    }
    return theRows
  }
  return function (columns, values, fieldToFormat, functionToFormat){
    timestampCol=-1;
    var tbl  = document.createElement('table');
    // console.log('columns='+columns);
    var html = '<thead>' + valconcat(columns, 'th', fieldToFormat, functionToFormat) + '</thead>';
    var rows = values.map(function(v){ return valconcat(v, 'td', fieldToFormat, functionToFormat); });
    html += '<tbody>' + valconcat(rows, 'tr') + '</tbody>';
    tbl.innerHTML = html;
    return tbl;
  }
}();

// Execute the commands when the button is clicked
function execEditorContents(chartType) {
  noerror();
  // console.log('execEditorContent: chartType='+chartType);
  if (typeof chartType !== 'string') chartType=undefined;
  execute (editor.getValue() + ';', chartType);
}
execBtn.addEventListener("click", execEditorContents, true);

// Performance measurement functions
var tictime;
if (!window.performance || !performance.now) {window.performance = {now:Date.now}}
function tic () {tictime = performance.now()}
function toc(msg) {
  var dt = performance.now()-tictime;
  console.log((msg||'toc') + ": " + dt + "ms");
}

// TODO: implement codemirrot properly: https://github.com/angular-ui/ui-codemirror http://plnkr.co/edit/?p=preview
// Add syntax highlihjting to the textarea
var editor = CodeMirror.fromTextArea(commandsElm, {
    mode: 'text/x-mysql',
    viewportMargin: Infinity,
    indentWithTabs: true,
    smartIndent: true,
    lineNumbers: true,
    matchBrackets : true,
    autofocus: true,
    extraKeys: {
      "Ctrl-Enter": execEditorContents,
      "Ctrl-S": savedb,
    }
});

// Load a db from a file
dbFileElm.onchange = function() {
  var f = dbFileElm.files[0];
  var r = new FileReader();
  r.addEventListener("progress", updateProgress);
  r.addEventListener("load", transferComplete);
  r.addEventListener("error", transferFailed);
  r.addEventListener("abort", transferCanceled);
  r.addEventListener("loadend", loadEnd);
  
  r.onload = function() {
    worker.onmessage = function () {
      toc("Loading database from uploaded file");
      // Show the schema of the loaded database
      editor.setValue("SELECT `name`, `sql`\n  FROM `sqlite_master`\n  WHERE type='table';");
      execEditorContents();
    };
    tic();
    try {
      console.log(r.result);
      worker.postMessage({action:'open',buffer:r.result}, [r.result]);
    }
    catch(exception) {
      worker.postMessage({action:'open',buffer:r.result});
    }
  }
  updateProgressBar('init',0);
  disableActions('#actions');
  r.readAsArrayBuffer(f);
}

// Save the db to a file
function savedb () {
  worker.onmessage = function(event) {
    toc("Exporting the database");
    var arraybuff = event.data.buffer;
    var blob = new Blob([arraybuff]);
    var a = document.createElement("a");
    a.href = window.URL.createObjectURL(blob);
    a.download = "sql.db";
    a.onclick = function() {
      setTimeout(function() {
        window.URL.revokeObjectURL(a.href);
      }, 1500);
    };
    a.click();
  };
  tic();
  worker.postMessage({action:'export'});
}
savedbElm.addEventListener("click", savedb, true);

// TODO: DONE! progress bar http://jsfiddle.net/GvdSy/ https://jsfiddle.net/zinoui/sx61fgm3/
function updateProgress(evt) {
  // console.log('evt.lengthComputable='+evt.lengthComputable);
  // console.log('evt.total='+evt.total);
  if (evt.lengthComputable) {
    var percentComplete = evt.loaded / evt.total;
    console.log("updateProgress "+percentComplete);
    updateProgressBar('update',percentComplete);
  } else {
    console.log("updateProgress unable to compute");
  }
}
function transferComplete(evt) { console.log("The transfer is complete"); }
function transferFailed(evt) { console.log("transferFailed"); }
function transferCanceled(evt) { console.log("transferCanceled"); }
function loadEnd(evt) { console.log("The transfer finished"); }

function execBtnLoadXhr2LoadFile(url) {
  var xhr = new XMLHttpRequest();
  updateProgressBar('init',0);
  xhr.addEventListener("progress", updateProgress);
  xhr.addEventListener("load", transferComplete);
  xhr.addEventListener("error", transferFailed);
  xhr.addEventListener("abort", transferCanceled);
  xhr.addEventListener("loadend", loadEnd);

  xhr.onload = function() {
    console.log(this.response); // THIS is the ArrayBuffer we want for the worker postMessage buffer !
    worker.onmessage = function () {
      toc("Loading database from url: "+url);
      // Show the schema of the loaded database
      editor.setValue("SELECT `name`, `sql`\n  FROM `sqlite_master`\n  WHERE type='table';");
      execEditorContents();
    };
    try {
      worker.postMessage({action:'open',buffer:this.response}, [this.response]);
    }
    catch(exception) {
      worker.postMessage({action:'open',buffer:this.response});
    }
  }
  tic();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';
  disableActions('#actions');
  xhr.send();
}
var execBtnLoadDbXhr0 = document.getElementById('loadDbXhr0');
var execBtnLoadDbXhrFull = document.getElementById('loadDbXhrFull');
// TODO: BUG: for some reason these addEventListener are executed on load of the page, why?
// execBtnLoadDbXhr0.addEventListener("click", execBtnLoadXhr2LoadFile('tuScraper.0.sqlite3'));
// execBtnLoadDbXhrFull.addEventListener("click", execBtnLoadXhr2LoadFile('tuScraper.sqlite3'));
execBtnLoadDbXhr0.onclick = function(e) { execBtnLoadXhr2LoadFile('tuScraper.0.sqlite3'); }
execBtnLoadDbXhrFull.onclick = function(e) { execBtnLoadXhr2LoadFile('tuScraper.sqlite3'); }

/*
var sqlDict = {
  'structure': "select name,sql from sqlite_master where type in ('table','view');",
  'classes': "SELECT * from classes LIMIT 100;",
  'fields': "SELECT * from fields LIMIT 100;",
  'history': "SELECT * from history LIMIT 1000;",
  'sql_mySurvey': "SELECT * from perso_fall2017;",
  'sql_ITEC': "SELECT * from  ITEC_fall2017;",
  'sql_ITEC231': "select timestamp,title,SeatsTaken,(SeatsOpen-waitlisttotal) from history,classes \
      where history.classnumber = '2792' \
      and history.classnumber = classes.classnumber \
      order by timestamp asc \
      LIMIT 100;",
  'sql_classChart': "SELECT x.timestamp as timestamp,x.openings as 'CIS212-001', \
       y.openings as 'ITEC250-002' \
  FROM (SELECT timestamp,(SeatsOpen-waitlisttotal) as openings, \
(\
    SELECT COUNT(*) \
    FROM history b \
    WHERE a.timestamp >= b.timestamp \
	and b.classnumber = 2768 \
) AS rnum \
FROM history a \
where a.classnumber = 2768) x \
    LEFT JOIN (SELECT timestamp,(SeatsOpen-waitlisttotal) as openings, \
(\
    SELECT COUNT(*) \
    FROM history b  \
    WHERE a.timestamp >= b.timestamp \
	and b.classnumber = 2781 \
) AS rnum \
FROM history a \
where a.classnumber = 2781) y \
     ON x.rnum=y.rnum;"
};
*/

function jsonEscape(str)  {
  return str.replace(/\\/g, "\\\\n").replace(/\r/g, "\\\\r").replace(/\t/g, "\\\\t");
}

var sqlDict = '';
function getJsonAsync(url, callback) {
  // https://www.w3schools.com/js/tryit.asp?filename=tryjson_http
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      // console.log(unescape(this.responseText));
      // https://jsonlint.com/
      // https://stackoverflow.com/questions/42068/how-do-i-handle-newlines-in-json
      callback(JSON.parse(unescape(this.responseText)));
    }
  };
  xhr.open("GET", url, true);
  xhr.send();
}

/* 
// Firefox: Synchronous XMLHttpRequest on the main thread is deprecated 
// async: false - xhr.open("GET", url, false);
// because of its detrimental effects to the end userâ€™s experience. For more help http://xhr.spec.whatwg.org/
var sqlDict = $.ajax({
  url : dirname(window.location.href)+"/sql.dict.json",
  type : "GET",
  contentType: "application/json",
  async: false
}).responseText;
*/

function setEditorSql(buttonId,sqlDict) {
  // console.log('setEditorSql: sqlDict['+buttonId+']='+sqlDict[buttonId]);
  editor.setValue(sqlDict[buttonId]);
}

// old school:
/* var execBtnInjectSql = document.getElementsByClassName('injectSql');
for (var i = 0; i < execBtnInjectSql.length; i += 1) {
  execBtnInjectSql[i].onclick = function(e) {
    setEditorSql(this.id);
    execute (editor.getValue() + ';');
  };
}*/
// jquery school:
function updateSqlButtons(sqlDict) {
  $(".injectSql").each(function(){
    this.onclick = function(e) {
      setEditorSql(this.id,sqlDict);
      // execute (editor.getValue() + ';', $(this).attr("chart"));  // 1.4
      execEditorContents($(this).attr("chart"));  // 1.4
    };
  });
}

// generate the hiddenTooltip out from sqlDict
function createHiddenTooltip(sqlDict) {
    // console.log('createHiddenTooltip: sqlDict='+sqlDict);
    // console.log(sqlDict);
  $(".injectSql").each(function(){
    if ($(this).attr("tooltip") !== "" ){
      // console.log(sqlDict);
      var tooltipRef = $(this).attr('tooltip');
      // console.log('createHiddenTooltip: tooltipRef='+tooltipRef);
      var div  = document.createElement('div');
      // console.log(sqlDict[tooltipRef]);
      var content = document.createTextNode(sqlDict[tooltipRef]); 
      div.id = "tooltip-"+tooltipRef;
      div.className = "hiddenTooltip";
      div.appendChild(content);
      document.body.appendChild(div);
      // $("body").append('<div id="tooltip-'+tooltipRef+'" class="hiddenTooltip">'+sqlDict[tooltipRef]+'</div>');
    }
  });
}

// TODO: add my own class switcher here:
// TODO: disable upload buttons for 4s after success
function updateProgressBar(state,percentComplete) {
  switch (state) {
    case 'init':
      $('.progressBar').removeClass('hide');
      break;
    default:
      $('.progressBar').css({ width: percentComplete * 100 + '%' });
      if (percentComplete === 1) { $('.progressBar').addClass('hide').css({ width: 0 }); }
      break;
  }
}

// https://stackoverflow.com/questions/23667086/why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchron
function setVarAsync() {
  getJsonAsync(dirname(window.location.href)+"/sql.dict.json", function(sqlDict) {
    createHiddenTooltip(sqlDict);
    simple_tooltip(".tip","tooltip");
    updateSqlButtons(sqlDict);
  });
}

var sqlDict;
$(document).ready(function(){
  setVarAsync();
});
